use std::evm::call_data_load
use raw_call::{RawCallHelper, MemoryEncoding}

const MAX_OWNER_COUNT: u8 = 50
const TX_MAX_DATA_SIZE: u256 = 128

type TransactionData = Array<u8, { TX_MAX_DATA_SIZE }>

trait AddressArrayExtensions{
  fn length(self) -> u256;
  fn push(self, _ item: address);
}

// This really sucks but Fe lacks these methods natively
// and wrapping an address array in a struct comes with some weird bugs
impl AddressArrayExtensions for Array<address, { MAX_OWNER_COUNT }> {
  fn length(self) -> u256 {
    let mut count: u256 = 0
    for item in self {
      if item != 0 {
        count += 1
      }
    }
    return count
  }

  fn push(mut self, _ val: address) {
    let mut index: u256 = 0
    for item in self {
      if item == 0 {
        self[index] = val
        return
      }
      index += 1
    }
    revert
  }
}

struct Confirmation {
    #indexed
    pub owner: address
    #indexed
    pub tx_id: u256
}

struct OwnerAddition {
    #indexed
    pub owner: address
}

struct Transaction {
    pub destination: address 
    pub value: u256 
    pub data: TransactionData
    pub data_length: u16
    pub executed: bool
}

impl MemoryEncoding for Transaction {
    fn write_mem(self) {
      // Very hacky way to copy the data into a fresh segment of memory
      // In the future, the compiler would likely optimize that away
      let mut x: TransactionData = self.data
    }
    fn byte_count(self) -> u16 {
        return self.data_length
    }
}

contract MultiSig {

  tx_count: u256
  transactions: Map<u256, Transaction>
  confirmations: Map<u256, Map<address, bool>>
  required_confirmations: u8
  owners: Array<address, { MAX_OWNER_COUNT }>
  is_owner: Map<address, bool>

  pub fn __init__(mut self, owners: Array<address, { MAX_OWNER_COUNT }>, required_confirmations: u8) {
    for owner in owners {
      // TODO: Look into this
      //if owner == 0 or self.is_owner[owner]{
      //  revert
      //}
      self.is_owner[owner] = true
    }
    self.owners = owners
    self.required_confirmations = required_confirmations
  }

  // Internal validation methods

  fn validate_not_executed(self, _ tx_id: u256) {
    if self.transactions[tx_id].executed {
      revert
    }
  }

  fn validate_owner_exists(self, _ owner: address) {
    if not self.is_owner[owner] {
      revert
    }
  }

  fn validate_owner_does_not_exist(self, _ owner: address) {
    if self.is_owner[owner] {
      revert
    }
  }

  fn validate_confirmed(self, _ tx_id: u256, _ owner: address) {
    if not self.confirmations[tx_id][owner] {
      revert
    }
  }

  fn validate_not_confirmed(self, _ tx_id: u256, _ owner: address) {
    if self.confirmations[tx_id][owner] {
      revert
    }
  }

  fn validate_tx_exists(self, _ tx_id: u256) {
    if self.transactions[tx_id].destination == 0 {
      revert
    }
  }

  fn validate_only_wallet(self, ctx: Context) {
    if ctx.msg_sender() != ctx.self_address() {
      revert
    }
  }

  fn validate_not_null(self, _ addr: address) {
    if addr == 0 {
      revert
    }
  }

  fn validate_valid_requirement(self, _ owner_count: u256, _ required: u256) {
    if owner_count > MAX_OWNER_COUNT or required > owner_count or required == 0 or owner_count == 0 {
      revert
    }
  }

  /// Returns the confirmation status of a transaction.
  pub fn is_confirmed(self, tx_id: u256) -> bool {
    let mut count: u8 = 0
    for owner in self.owners.to_mem() {
      if self.confirmations[tx_id][owner] {
        count += 1
      }
      if count == self.required_confirmations {
        return true
      }
    }
    return false
  }

  // TODO: Add checks
  fn add_transaction(mut self, destination: address, value: u256, data: TransactionData, data_length: u16) -> u256{
    let tx_id: u256 = self.tx_count
    self.transactions[tx_id] = Transaction (
      destination,
      value,
      data,
      data_length,
      executed: false
    )
    self.tx_count += 1
    return tx_id
  }

  // Allows an owner to submit and confirm a transaction.
  pub fn submit_transaction(mut self, mut ctx: Context, destination: address, value: u256, data: TransactionData, data_length: u16) -> u256{
    let tx_id: u256 = self.add_transaction(destination, value, data, data_length)
    self.confirm_transaction(ctx, tx_id)
    return tx_id
  }

  /// Allows an owner to confirm a transaction
  pub fn confirm_transaction(mut self, mut ctx: Context, tx_id: u256) {
    self.validate_owner_exists(ctx.msg_sender())
    self.validate_tx_exists(tx_id)
    self.validate_not_confirmed(tx_id, ctx.msg_sender())

    self.confirmations[tx_id][ctx.msg_sender()] = true
    ctx.emit(Confirmation(owner: ctx.msg_sender(), tx_id))
    self.execute_transaction(ctx, tx_id)
  }


  pub fn execute_transaction(mut self, ctx: Context, tx_id: u256) {
    self.validate_not_executed(tx_id)
    self.validate_owner_exists(ctx.msg_sender())
    self.validate_confirmed(tx_id, ctx.msg_sender())

    if self.is_confirmed(tx_id) {
      let mut tx: Transaction = self.transactions[tx_id].to_mem()
      self.transactions[tx_id].executed = true
      // TODO: Handle failure
      RawCallHelper::call(tx.destination, tx.value, tx)
    }
  }

  pub fn add_owner(mut self, mut ctx: Context, owner: address) {
    self.validate_only_wallet(ctx)
    self.validate_owner_does_not_exist(owner)
    self.validate_not_null(owner)
    self.validate_valid_requirement(self.owners.to_mem().length() + 1, self.required_confirmations)

    self.is_owner[owner] = true
    let mut owners: Array<address, { MAX_OWNER_COUNT }> = self.owners.to_mem()
    owners.push(owner)
    self.owners = owners
    ctx.emit(OwnerAddition(owner))
  }

  pub fn get_owners(self) -> Array<address, { MAX_OWNER_COUNT }> {
    return self.owners.to_mem()
  }
}